services:
  # --- INFRA ---
  redis:
    image: redis:alpine
    volumes:
      - redis_data:/data

  db:
    image: timescale/timescaledb:latest-pg14
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=llminfra
    volumes:
      - db_data:/var/lib/postgresql/data

  # --- LOCAL WORKER TEST (NO GPU) ---
  # Lightweight fake vLLM that serves GET /v1/models for readiness checks.
  mock-vllm:
    image: python:3.11-slim
    profiles: ["worker-local"]
    command: ["python", "-u", "/app/mock_vllm.py"]
    environment:
      - MODEL_ID=${MOCK_VLLM_MODEL_ID:-demo-model}
      - PORT=8000
      # Expose minimal vLLM-style Prometheus metrics for agent parsing (queue depth, running).
      - VLLM_NUM_REQUESTS_WAITING=${MOCK_VLLM_REQUESTS_WAITING:-7}
      - VLLM_NUM_REQUESTS_RUNNING=${MOCK_VLLM_REQUESTS_RUNNING:-1}
    volumes:
      - ./inventiv-worker-mock/mock_vllm.py:/app/mock_vllm.py:ro
    ports:
      - "${MOCK_VLLM_HOST_PORT:-18000}:8000"
      # Expose worker-agent health endpoints too (same network namespace via worker-agent network_mode).
      - "${WORKER_AGENT_HOST_PORT:-18080}:8080"

  # Agent-only worker (no vLLM) for local testing.
  worker-agent:
    build:
      context: ./inventiv-worker
      dockerfile: Dockerfile.agent
    profiles: ["worker-local"]
    # Share the same network namespace/IP as mock-vllm so the instance has a single IP
    # with multiple ports (like a real VM: vLLM on :8000 + health/metrics on :8080).
    network_mode: "service:mock-vllm"
    environment:
      - CONTROL_PLANE_URL=http://api:8003
      # Use a deterministic token for local/dev (avoid bootstrap special-cases).
      - WORKER_AUTH_TOKEN=${WORKER_AUTH_TOKEN:-dev-worker-token}
      - INSTANCE_ID=${INSTANCE_ID:-}
      - MODEL_ID=${MOCK_VLLM_MODEL_ID:-demo-model}
      # Enable synthetic GPU metrics for local mock (no nvidia-smi in docker).
      - WORKER_SIMULATE_GPU_COUNT=${WORKER_SIMULATE_GPU_COUNT:-1}
      - WORKER_SIMULATE_GPU_VRAM_MB=${WORKER_SIMULATE_GPU_VRAM_MB:-24576}
      - VLLM_BASE_URL=http://mock-vllm:8000
      - WORKER_HEALTH_PORT=8080
      - WORKER_HEARTBEAT_INTERVAL_S=5
      - PYTHONUNBUFFERED=1
      # INSTANCE_ID must be provided at runtime (docker compose run -e INSTANCE_ID=...)
    depends_on:
      - mock-vllm
      - orchestrator

  # --- UI (exposed on host) ---
  # Run Next.js dev server inside Docker so the browser only talks to the UI port.
  # All backend calls go through same-origin proxy routes `/api/backend/*` implemented in Next route handlers.
  frontend:
    image: node:20-alpine
    profiles: ["ui"]
    working_dir: /repo
    # Monorepo workspaces: install once at repo root; run Next from the frontend workspace.
    # Use webpack dev server for reliable watch/HMR across workspaces.
    command: ["sh", "-lc", "npm install --no-audit --no-fund && if [ ! -e node_modules/ia-designsys ] || [ ! -e node_modules/ia-widgets ]; then echo 'üîß Missing workspace links (ia-designsys/ia-widgets) in /repo/node_modules ‚Üí forcing reinstall'; npm install --no-audit --no-fund --force; fi && if [ -e inventiv-frontend/node_modules/ia-widgets ] || [ -e inventiv-frontend/node_modules/ia-designsys ]; then echo 'üßπ Removing shadowed workspace copies in inventiv-frontend/node_modules (would hide monorepo packages)'; rm -rf inventiv-frontend/node_modules/ia-widgets inventiv-frontend/node_modules/ia-designsys; fi && echo \"‚ÑπÔ∏è  ia-widgets resolves to: $(node -e 'process.chdir(\"inventiv-frontend\"); console.log(require.resolve(\"ia-widgets\"))')\" && npm -w inventiv-frontend run dev -- --webpack --hostname 0.0.0.0 --port 3000"]
    environment:
      # Frontend server-side proxy target (docker network)
      - API_INTERNAL_URL=http://api:8003
      # Improve file watching reliability on macOS/Windows with Docker bind mounts
      # Also helps on Linux in some cases
      - CHOKIDAR_USEPOLLING=1
      - WATCHPACK_POLLING=true
      - NODE_ENV=development
    volumes:
      - .:/repo
      - ui_node_modules:/repo/node_modules
    ports:
      - "${UI_HOST_PORT:-3000}:3000"
    depends_on:
      - api

  # --- SERVICES (RUST) ---
  orchestrator:
    build:
      context: .
      dockerfile: Dockerfile.rust
      args:
        SERVICE_NAME: inventiv-orchestrator
    command:
      [
        "sh",
        "-c",
        "echo 'üîç Checking compilation before starting...' && FEAT=\"\"; if [ -n \"$$ORCHESTRATOR_FEATURES\" ]; then FEAT=\"--features $$ORCHESTRATOR_FEATURES\"; fi && cargo check --package inventiv-orchestrator --release $$FEAT && echo '‚úÖ Compilation check passed, starting with cargo watch...' && cargo watch -w inventiv-orchestrator -w inventiv-common -w sqlx-migrations -x \"run --release -p inventiv-orchestrator $$FEAT\"",
      ]
    volumes:
      - .:/app # Source code mount for hot reload
      # Secrets (dev/staging/prod): allow reading tokens from files without baking them into env.
      - ${SECRETS_DIR:-./deploy/secrets}:/run/secrets:ro
      # Docker socket: allow orchestrator to manage mock runtimes via docker compose
      - /var/run/docker.sock:/var/run/docker.sock:ro
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/llminfra
      - REDIS_URL=redis://redis:6379
      - CARGO_TARGET_DIR=/app/target/inventiv-orchestrator
      # Enable optional provider implementations via Cargo features (dev/test only).
      - ORCHESTRATOR_FEATURES=${ORCHESTRATOR_FEATURES:-provider-scaleway,provider-mock}
      - PROVIDER=${PROVIDER:-scaleway}
      # Mock provider runtime management (Docker compose)
      - PROJECT_ROOT=/app
      - CONTROLPLANE_NETWORK_NAME=${CONTROLPLANE_NETWORK_NAME:-inventiv-agents-worker-fixes_default}
      - SCALEWAY_PROJECT_ID=${SCALEWAY_PROJECT_ID:-}
      - SCALEWAY_ACCESS_KEY=${SCALEWAY_ACCESS_KEY:-}
      - SCALEWAY_SECRET_KEY=${SCALEWAY_SECRET_KEY:-}
      - SCALEWAY_ORGANIZATION_ID=${SCALEWAY_ORGANIZATION_ID:-}
      - SCALEWAY_SSH_PUBLIC_KEY_FILE=/app/.ssh/llm-studio-key.pub
      - WORKER_AUTH_TOKEN=${WORKER_AUTH_TOKEN:-dev-worker-token}
      - WORKER_HEALTH_PORT=${WORKER_HEALTH_PORT:-8080}
      - WORKER_AUTO_INSTALL=${WORKER_AUTO_INSTALL:-0}
      - WORKER_CONTROL_PLANE_URL=${WORKER_CONTROL_PLANE_URL:-}
      - WORKER_CONTROL_PLANE_URL_FILE=${WORKER_CONTROL_PLANE_URL_FILE:-}
      - WORKER_AUTO_INSTALL_INSTANCE_PATTERNS=${WORKER_AUTO_INSTALL_INSTANCE_PATTERNS:-}
      - WORKER_MODEL_ID=${WORKER_MODEL_ID:-}
      - WORKER_VLLM_IMAGE=${WORKER_VLLM_IMAGE:-}
      - WORKER_AGENT_SOURCE_URL=${WORKER_AGENT_SOURCE_URL:-}
      # Optional (for private HF models): token forwarded to worker bootstrap scripts
      - WORKER_HF_TOKEN=${WORKER_HF_TOKEN:-}
      # Backwards-compat alias: some env files use HUGGINGFACE_TOKEN
      - HUGGINGFACE_TOKEN=${HUGGINGFACE_TOKEN:-}
      - WORKER_HF_TOKEN_FILE=${WORKER_HF_TOKEN_FILE:-}
      - WORKER_EXPOSE_PORTS=${WORKER_EXPOSE_PORTS:-1}
      - WORKER_SSH_PRIVATE_KEY_FILE=${WORKER_SSH_PRIVATE_KEY_FILE:-/app/.ssh/llm-studio-key}
      - WORKER_SSH_USER=${WORKER_SSH_USER:-root}
      - RUST_LOG=debug
    depends_on:
      - db
      - redis

  api:
    build:
      context: .
      dockerfile: Dockerfile.rust
      args:
        SERVICE_NAME: inventiv-api
    # Build check before starting: fail fast if compilation fails
    command: >
      sh -c "
        echo 'üîç Checking compilation before starting...' &&
        cargo check --package inventiv-api --release &&
        echo '‚úÖ Compilation check passed, starting with cargo watch...' &&
        cargo watch -w inventiv-api -w inventiv-common -w sqlx-migrations -x 'run --release -p inventiv-api'
      "
    volumes:
      - .:/app # Source code mount for hot reload
      # Default admin password file (dev/local)
      - ${SECRETS_DIR:-./deploy/secrets}:/run/secrets:ro
    environment:
      - REDIS_URL=redis://redis:6379
      - DATABASE_URL=postgresql://postgres:password@db:5432/llminfra
      - CARGO_TARGET_DIR=/app/target/inventiv-api
      - AUTO_SEED_CATALOG=1
      - SEED_CATALOG_PATH=/app/seeds/catalog_seeds.sql
      - BOOTSTRAP_DEFAULT_ADMIN=${BOOTSTRAP_DEFAULT_ADMIN:-1}
      # If enabled, refresh the admin password on startup (useful when DB volume persists across runs/tests).
      - BOOTSTRAP_UPDATE_ADMIN_PASSWORD=${BOOTSTRAP_UPDATE_ADMIN_PASSWORD:-0}
      - DEFAULT_ADMIN_USERNAME=${DEFAULT_ADMIN_USERNAME:-admin}
      - DEFAULT_ADMIN_EMAIL=${DEFAULT_ADMIN_EMAIL:-admin@inventiv.local}
      - DEFAULT_ADMIN_PASSWORD_FILE=${DEFAULT_ADMIN_PASSWORD_FILE:-/run/secrets/default_admin_password}
      # Dev convenience: allow a global worker token for heartbeat auth.
      - WORKER_AUTH_TOKEN=${WORKER_AUTH_TOKEN:-dev-worker-token}
      - WORKER_AUTO_INSTALL=${WORKER_AUTO_INSTALL:-0}
      - WORKER_AUTO_INSTALL_INSTANCE_PATTERNS=${WORKER_AUTO_INSTALL_INSTANCE_PATTERNS:-}
      - RUST_LOG=debug
    depends_on:
      - redis
      - db

  finops:
    build:
      context: .
      dockerfile: Dockerfile.rust
      args:
        SERVICE_NAME: inventiv-finops
    # Build check before starting: fail fast if compilation fails
    command: >
      sh -c "
        echo 'üîç Checking compilation before starting...' &&
        cargo check --package inventiv-finops --release &&
        echo '‚úÖ Compilation check passed, starting with cargo watch...' &&
        cargo watch -w inventiv-finops -w inventiv-common -w sqlx-migrations -x 'run --release -p inventiv-finops'
      "
    volumes:
      - .:/app # Source code mount for hot reload
    environment:
      - REDIS_URL=redis://redis:6379
      - DATABASE_URL=postgresql://postgres:password@db:5432/llminfra
      - CARGO_TARGET_DIR=/app/target/inventiv-finops
      - RUST_LOG=debug
    depends_on:
      - redis
      - db

volumes:
  redis_data:
  db_data:
  ui_node_modules:
